"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class Playlist extends Array {
    constructor() {
        super(...arguments);
        this.loop = false;
        this.autoplay = false;
        this._pos = 0;
    }
    get pos() {
        return this._pos;
    }
    get current() {
        return this[this._pos];
    }
    reset() {
        this.splice(0, this.length);
        this._pos = 0;
    }
    hasPrev() {
        return this._pos > 0;
    }
    prev() {
        if (this.hasPrev()) {
            this._pos -= 1;
            return true;
        }
        if (this.loop) {
            this._pos = this.length - 1;
            return true;
        }
        return false;
    }
    hasNext() {
        return this._pos < this.length - 1;
    }
    next() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.current && this.current.loop)
                return true;
            if (this.hasNext()) {
                this._pos += 1;
                return true;
            }
            if (this.loop) {
                this._pos = 0;
                return true;
            }
            if (this.autoplay) {
                const next = yield this.current.next();
                if (next) {
                    this.push(next);
                    this._pos += 1;
                    return true;
                }
            }
            return false;
        });
    }
    shuffle() {
        for (let i = this.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            const temp = this[i];
            this[i] = this[j];
            this[j] = temp;
        }
        return this;
    }
    add(content, services, { position = Infinity, searchType = 'song', } = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const added = [];
            for (const service of services) {
                const fetchable = service.fetchable(content);
                added.push(...(yield service.fetch(fetchable, searchType)));
            }
            this.splice(position, 0, ...added);
            return added;
        });
    }
}
exports.default = Playlist;
